Example 2: Direct Access
==============================


Goals:
---------
1. To directly access the value inside a Lua TValue object through pointer manipulation.
2. To directly access an arbitrary member field of a C struct.

Note:
--------
1. All changes made by us to the Lua source is marked by the following tags. This is to make it easier to see the changes using the text editor's find tool.

//@POSEIDON_LUA: BEGIN
//============================================================================================

//@POSEIDON_LUA: END
//============================================================================================


Instructions:
------------------
1. Navigate to "Poseidon_Lua/lua-5.3.3" and enter "make linux".
   This will compile the Lua source in the "Poseidon_Lua/lua-5.3.3/src" directory.

2. Navigate to "Poseidon_Lua/lua-5.3.3/src" and enter the following to run the Adder.lua script.


Poseidon_Lua/lua-5.3.3/src$ ./lua Adder.lua 0 2 20
===================================
ARG SIZE: 3
===================================
ARG:
1 : 0
2 : 2
3 : 20
RESULT_SUM : 22
BOTTOM_VALUE : -3003
FOO : --
0 : Adder.lua
-1 : ./lua
===================================
SUM : 22
===================================



3. For a detailed explanation of what Adder.lua does, please read through Example 1 ( Instructions1.txt ).

4. Open "Poseidon_Lua/lua-5.3.3/src/lopcodes.h".
   Check the "typedef enum {...} OpCode ;" statement.
   You will see that we have defined our own opcode named "OP_LOAD_INT_2".

5. Open "Poseidon_Lua/lua-5.3.3/src/lvm.c". 
   This is where the Lua Virtual Machine is implemented.
   Notice that we have included the "<stddef.h>" library.
   This library contains the "offsetof()" macro, which we will use later.

6. Check the "luaV_execute()" function.
   This is where the main interpreter loop is located.
   You can see that we use a chain of "if/else" statements to run our opcodes as the first instructions of any program.
   The rest of the program follows afterwards as usual.

7. First, the opcode "OP_LOAD_INT_1" is executed.
   Please see Example 1 ( Instructions1.txt ) for details.

8. Second, the opcode "OP_LOAD_INT_2" is executed.
   As part of the instruction set up, we are pushing a value to the stack as an argument.
   The value is the byte offset of the "bottomValue" member field of the C struct named Foo.
   The value is obtained through the use of the "offsetof()" macro.

9. Our opcode "OP_LOAD_INT_2" executes as follows.
   First, we fetch the byte offset of the "bottomValue" member field of the C struct named Foo from the stack.
   Note that we are using direct access to fetch the value from the TValue object wrapping it.
      Open "Poseidon_Lua/lua-5.3.3/src/lobject.h".
      Note that we could have used the "ivalue()" macro to fetch the same value.
      However, by using direct access instead, we avoid the extra typechecking performed by the code in "ttisinteger()".
   Next, from the global "arg" table, we fetch the TValue object indexed by "FOO".
      Open "Poseidon_Lua/lua-5.3.3/src/lua.c".
      Check the "insertSumHere()" function.
      Our "insertSumHere()" function mallocs a C struct named Foo, which is defined in the "Poseidon_Lua/lua-5.3.3/src/lua.h" file.
      Note that we have set the value of the "bottomValue" member field to "-3003".
      The C struct is wrapped in a TValue object and pushed into the global "arg" table with the index "FOO".
      This is the same TValue object that we have just fetched.
   Next, fetch a reference to the C struct.
   Note that we are using direct access to fetch this value from the TValue object wrapping it.
      Open "Poseidon_Lua/lua-5.3.3/src/lobject.h".
      Note that we could have used the "pvalue()" macro to fetch the same value.
      However, by using direct access instead, we avoid the extra typechecking performed by the code in "ttislightuserdata()".
   We perform pointer arithmetic using the reference to the C struct and the byte offset of the "bottomValue" member field.
   We initialize the "resultInt" pointer with the resulting value.
   The "resultInt" pointer now points to the "bottomValue" member field of the C struct that is indexed by "FOO".
   The value pointed to by the "resultInt" pointer is pushed into the global "arg" table with the index "BOTTOM_VALUE".
   You can see the value of "BOTTOM_VALUE" in the global "arg" table from the prinout from our Pure Lua script.

10. How do we know that this works?
    Different values for the first command line argument will result in different values for "RESULT_SUM".
    However, the value for "BOTTOM_VALUE" will always remain the same, at "-3003".
       If the first command line argument is "0", the value of "RESULT_SUM" will be the same as "SUM", as computed by our Pure Lua script.
       If the first command line argument is "-1", the value of "RESULT_SUM" will be "-202", the value of the "topValue" member field of our C struct.
       If the first command line argument is "1", the value of "RESULT_SUM" will be "-3003", the value of the "bottomValue" member field of our C struct.
       If the first command line argument is some other arbitrary value, the value of "RESULT_SUM" will also be some arbitrary value.


